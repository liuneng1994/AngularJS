# 创建自定义指令

这个文档解释了什么时候需要创建自定义指令和如果去实现它们.

## 什么是指令

站在一个高的层面上看,指令是在DOM元素上的标记\(如属性,元素名,注释或者CSS类\),通知AngularJS的**HTML编译器**\(`$compile`\)去给DOM元素添加一些指定的行为\(如通过事件监听器\),或者改变DOM元素和它的子元素.

Angular实现了一系列的内建指令,像`ngBind`,`ngModel`和`ngClass`.就像你可以创建控制器,服务一样,你也可以创建你自己的指令.在Angular启动你的应用程序的时候,HTML编译器会遍历DOM并且匹配DOM元素上的指令.

> **编译一个HTML模板的含义是什么**:对于AngularJS而言,"编译"的意思是添加指令到HTML上,使其具有交互性.使用编译这个术语的原因是,在编译语言中会编译处理源码并递归地处理附加的指令镜像.

## 匹配指令

在能够实现自己的指令之前,我们需要知道Angular的HTML编译器是如何决定什么时候去使用一个给定的指令.

与元素匹配一个选择器一样,我们将指令是元素声明的一部分定义为一个元素匹配了一个指令.

在接下来的例子中,我们说这个`<input>`元素匹配了`ngModel`指令.

```html
<input ng-model="foo">
```

下面的`<input>`元素也匹配了`ngModel`:

```html
<input data-ng-model="foo">
```

下面的元素匹配了`person`指令:

```html
<person>{{name}}</person>
```

### 标准化

Angular将一个元素的标签和属性名标准化,以此决定元素匹配哪些指令.我们更喜欢使用以大小写敏感的驼峰规则作为指令的标准名称\(如`ngModel`\).然而,因为HTML是大小写不敏感的,我们通常在DOM中使用小写的格式,以横杠`-`分隔属性\(如`ng-model`\).

标准化的处理有以下规则:

1. 跳过元素和属性的`X-`和`data-`前缀.
2. 转换`:`,`-`或者`_`分隔的名称成驼峰规则.  

例如,下面的表单中的元素都可以匹配到`ngBind`指令:
**index.html**

```html
<div ng-controller="Controller">
  Hello <input ng-model='name'> <hr/>
  <span ng-bind="name"></span> <br/>
  <span ng:bind="name"></span> <br/>
  <span ng_bind="name"></span> <br/>
  <span data-ng-bind="name"></span> <br/>
  <span x-ng-bind="name"></span> <br/>
</div>
```

**script.js**

```js
angular.module('docsBindExample', [])
.controller('Controller', ['$scope', function($scope) {
  $scope.name = 'Max Karl Ernst Ludwig Planck (April 23, 1858 – October 4, 1947)';
}]);
```

> **最佳实践**:推荐使用`-`分隔的格式\(如`ngBind`写成`ng-bind`\).如果你想要使用一个HTML验证工具,你可以带有`data-`前缀的版本\(如`ngBind`写成`data-ng-bind`\).其他因为历史原因的格式可以被接受,但是建议避免去使用.

### 指令类型

`$compile`可以匹配在元素名,属性,类名和注释中的指令.

所有Angular提供的指令都能够用于属性名,标签名,注释或者类名.下面的例子演示了在同一个模板中使用不同的方式引用指令.

```html
<my-dir></my-dir>
<span my-dir="exp"></span>
<!-- directive: my-dir exp -->
<span class="my-dir: exp;"></span>
```

> **最佳实践**:推荐通过标签名或者类名使用指令,少用类名和注释.这样可以更容易的匹配到元素上的指令.
> 
> **最佳实践**:注释指令通常使用在DOM API限制了创建跨越多个元素的指令时\(如在`<table>`元素内\).Angular 1.2介绍了`ng-repeat-start`和`ng-repeat-end`去更好的解决这个问题开发者被鼓励去在可能的时候使用注解指令.

## 创建指令

首先让我们讨论一下注册指令的API.就像控制器,指令也被注册在模块中.可以通过`module.directive`API去注册一个指令.`module.directive`有一个标准指令名参数和一个工厂函数.这个工厂函数应该返回一个具有不同选项的对象,用来告知`$compile`在匹配到指令是要完成那些工作.

工厂函数只会在指令被第一次匹配时执行一次.你可以在这之中执行任何初始化操作.这个函数使用`$injector.invoke`执行的,这样就可以使用依赖注入.

下面将会看到一个比较普遍的关于指令的例子,然后深入的讨论不同的选项和编译过程.

> **最佳实践**:为了避免与未来标准的冲突,最好为你的指令名添加前缀.例如,你创建了一个`<carousel>`指令,如果HTML7引入了相同的元素,这就会出现问题.一个两道三个字母的前缀\(如`btfCarousel`\)就可以避免这种问题的发生.同样的不要使用`ng`作为你指令的前缀,这很可能会与未来版本的Angular产生冲突.

下面的例子我们会使用`my`前缀\(如`myCustomer`\).

### 模板扩展指令

假设你有一大块模板去显示顾客的信息.这个模板在你的代码中出现过很多次.当你修改其中一个地方,你不得不去修改其他位置.这就是一个使用指令去简化模板的好机会.

下面创建了一个简单替换静态模板的指令:
**script.js**

```js
angular.module('docsSimpleDirective', [])
.controller('Controller', ['$scope', function($scope) {
  $scope.customer = {
    name: 'Naomi',
    address: '1600 Amphitheatre'
  };
}])
.directive('myCustomer', function() {
  return {
    template: 'Name: {{customer.name}} Address: {{customer.address}}'
  };
});
```

**index.html**

```html
<div ng-controller="Controller">
  <div my-customer></div>
</div>
```

注意我们在指令中使用了数据绑定.在`$compile`编译和链接`<div my-customer></div>`之后,会尝试匹配在子元素中的指令.这意味着我们可以在指令中组合其它指令.

在上面的例子中我们使用的`template`选项的值只有一行.但是在模板规模变大的时候会成为一个恼人的问题.

> **最佳实践**:除非你的模板非常小,最好把模板分开到单独的HTML文件中,然后通过`templateUrl`选项去加载.

如果你熟悉`ngInclude`,`templateUrl`和它一样.下面是一个使用`templateUrl`的例子.

**script.js**

```js
angular.module('docsTemplateUrlDirective', [])
.controller('Controller', ['$scope', function($scope) {
  $scope.customer = {
    name: 'Naomi',
    address: '1600 Amphitheatre'
  };
}])
.directive('myCustomer', function() {
  return {
    templateUrl: 'my-customer.html'
  };
});
```

**index.html**

```html
<div ng-controller="Controller">
  <div my-customer></div>
</div>
```

**my-customer.html**

```html
Name: {{customer.name}} Address: {{customer.address}}
```

`templateUrl`也可以使用一个返回HTML模板url的函数去加载.Angular会通过两个参数去调用这个函数:一个是指令所在的DOM元素,和元素关联的`attr`对象.

> **注意**:目前你不能在`templateUrl`函数中访问`scope`变量,因为模板在域初始化前就被请求了.

**script.js**

```js
angular.module('docsTemplateUrlDirective', [])
.controller('Controller', ['$scope', function($scope) {
  $scope.customer = {
    name: 'Naomi',
    address: '1600 Amphitheatre'
  };
}])
.directive('myCustomer', function() {
  return {
    templateUrl: function(elem, attr) {
      return 'customer-' + attr.type + '.html';
    }
  };
});
```

**index.html**

```html
<div ng-controller="Controller">
  <div my-customer type="name"></div>
  <div my-customer type="address"></div>
</div>
```

**customer-name.html**

```html
Name: {{customer.name}}
```

**customer-address.html**

```html
Address: {{customer.address}}
```

> 当你在创建一个指令是,默认会被限制只能在元素和属性中使用.为了创建能够被类名触发的指令,你需要使用`restrict`选项.

`restrict`选项可以被设置为:

* `'A'`- 只匹配属性名
* `'E'`- 只匹配元素名
* `'C'`- 只匹配类名
* `'M'`- 只匹配注释

这些约束可以在需要时结合在一起:

* `'AEC'`- 匹配元素,属性或类名

> **如何选择使用属性还是元素?**在模板的控件中创建一个组件时使用元素.普遍的目的是为你的模块部分创建DSL.当你为了给已存在的元素增加新的功能时使用元素.

### 指令的隔离域\(isolate scope\)

上面的`myCustomer`指令非常不错,但是它有一个致命的缺陷.我们只能在给定的域中使用一次.

在它的当前实现中,我们为了能够重用指令,需要在每一次使用时创建不同的控制器.

**script.js**

```js
angular.module('docsScopeProblemExample', [])
.controller('NaomiController', ['$scope', function($scope) {
  $scope.customer = {
    name: 'Naomi',
    address: '1600 Amphitheatre'
  };
}])
.controller('IgorController', ['$scope', function($scope) {
  $scope.customer = {
    name: 'Igor',
    address: '123 Somewhere'
  };
}])
.directive('myCustomer', function() {
  return {
    restrict: 'E',
    templateUrl: 'my-customer.html'
  };
});
```

**index.html**

```html
<div ng-controller="NaomiController">
  <my-customer></my-customer>
</div>
<hr>
<div ng-controller="IgorController">
  <my-customer></my-customer>
</div>
```

**my-customer.html**

```html
Name: {{customer.name}} Address: {{customer.address}}
```

这显然不是一个好的解决方法.

要怎样才能将指令内部的域和外部的与隔离开,并且将外部的域映射到指令内的域.我们可以通过创建**隔离域**(isolate scope)来实现.为了创建隔离域,需要使用指令的`scope`选项:

**script.js**
```js
angular.module('docsIsolateScopeDirective', [])
.controller('Controller', ['$scope', function($scope) {
  $scope.naomi = { name: 'Naomi', address: '1600 Amphitheatre' };
  $scope.igor = { name: 'Igor', address: '123 Somewhere' };
}])
.directive('myCustomer', function() {
  return {
    restrict: 'E',
    scope: {
      customerInfo: '=info'
    },
    templateUrl: 'my-customer-iso.html'
  };
});
```
**index.html**
```html
<div ng-controller="Controller">
  <my-customer info="naomi"></my-customer>
  <hr>
  <my-customer info="igor"></my-customer>
</div>
```
**my-customer-iso.html**
```html
Name: {{customerInfo.name}} Address: {{customerInfo.address}}
```

观察`index.html`,第一个`<my-customer>`元素绑定了`info`属性的值为`naomi`,这个属性已经位于控制器的域中.第二个绑定`info`的值为`igor`.

仔细观察一下scope选项:
```html
//...
scope: {
  customerInfo: '=info'
},
//...
```
这个**scope选项**是一个为每一个绑定的隔离域包含一个属性的对象.在这个例子中只有一个属性:
*  属性的名称是`customerInfo`,对应指令隔离域的`cunstomerInfo`属性.
*  值`=info`告诉了`$compile`去绑定`info`属性.

>  **注意**:在scope选项中的`=attr`属性是像指令名一样标准化的名称.为了绑定`<div bind-to-this="thing">`中的属性,你需要指定`=bindToThis`.

当元素上的属性名与想要绑定的指令内的属性名一样,你可以使用更简单的语法:
```js
...
scope: {
  // same as '=customer'
  customer: '='
},
...
```
除了能够绑定不同的数据到指令内的域,使用隔离域还有另一个作用.

下面的例子会添加另一个属性`vojta`到我们的域中,然后去尝试在指令模板中访问它.

**script.js**
```js
angular.module('docsIsolationExample', [])
.controller('Controller', ['$scope', function($scope) {
  $scope.naomi = { name: 'Naomi', address: '1600 Amphitheatre' };
  $scope.vojta = { name: 'Vojta', address: '3456 Somewhere Else' };
}])
.directive('myCustomer', function() {
  return {
    restrict: 'E',
    scope: {
      customerInfo: '=info'
    },
    templateUrl: 'my-customer-plus-vojta.html'
  };
});
```
**index.html**
```html
<div ng-controller="Controller">
  <my-customer info="naomi"></my-customer>
</div>
```
**my-customer-plus-vojta.html**
```html
Name: {{customerInfo.name}} Address: {{customerInfo.address}}
<hr>
Name: {{vojta.name}} Address: {{vojta.address}}
```
注意`{{vojta.name}}`和`{{vojta.address}}`会显示空,意味着它们是未定义的.尽管我们在控制器中定义了`vajta`属性,但是在指令中是不可用的.

顾名思义,指令的隔离域(isolate scope)会将除了显式添加到`scope:{}`中的哈希对象外的所有模型隔离在外.这在构建一个可重用组件时非常有用,因为它阻止了组件去改变除了你显式传递的属性外的所有模型属性.


